/*
 * $Id: xmlparser.c,v 1.3 2001/09/11 00:51:57 sean_stuckless Exp $
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <string.h>

#include <gtk/gtk.h>

#include <parser.h>
#include <parserInternals.h>

#include "xmlparser.h"

/* different parse states */
#define STATE_UNKNOWN   0
#define STATE_STARTTAG  1 
#define STATE_TEXT      2
#define STATE_ENDTAG    3
#define STATE_CDATA     4

/* size of the default string buffers */
#define MAX_BUFFER_SIZE 4096
#define MAX_STRING_BUFFER_SIZE 1024


/* prototypes */
inline void append(AppParseState *state, char *str, int len);
inline char *blankIfOnlyWhitespace(char *str);
inline void forgetNode(AppParseState *state);
inline void addNode(AppParseState *state);
inline void setState(AppParseState *state, int stateValue); 
inline void allocateBuffer(AppParseState *state, int len);

void       tree_comment_cdata_collapse (GtkTreeItem *treeitem, gpointer user_data);
void       tree_comment_cdata_expand   (GtkTreeItem *treeitem, gpointer user_data);

static void processDTD(AppParseState *state, char *name, char *publicId, char *systemId);

/* SAX Structure */
static xmlSAXHandler appSAXParser = {
   (internalSubsetSAXFunc)processDTD, /* internalSubset */
   0, /* isStandalone */
   0, /* hasInternalSubset */
   0, /* hasExternalSubset */
   0, /* resolveEntity */
   (getEntitySAXFunc)NULL, /* getEntity */
   0, /* entityDecl */
   0, /* notationDecl */
   0, /* attributeDecl */
   0, /* elementDecl */
   0, /* unparsedEntityDecl */
   0, /* setDocumentLocator */
   (startDocumentSAXFunc)handleStartDocument, /* startDocument */
   (endDocumentSAXFunc)handleEndDocument, /* endDocument */
   (startElementSAXFunc)handleStartElement, /* startElement */
   (endElementSAXFunc)handleEndElement, /* endElement */
   0, /* reference */
   (charactersSAXFunc)handleCharacters, /* characters */
   0, /* ignorableWhitespace */
   0, /* processingInstruction */
   (commentSAXFunc)handleComment, /* comment */
   (warningSAXFunc)NULL, /* warning */
   (errorSAXFunc)NULL, /* error */
   (fatalErrorSAXFunc)NULL, /* fatalError */
   (getParameterEntitySAXFunc)NULL, /* getParameterEntity */
   (cdataBlockSAXFunc)handleCdataBlock, /* cdataBlock */
   (externalSubsetSAXFunc)NULL, /* externalSubset */
};

/* append str to buffer in AppParseState depending on state */
inline void append(AppParseState *state, char *str, int len) {
   int i=0;
   char *ptr = NULL;

   /* set the buffer to append */
   if (state->state == STATE_STARTTAG) ptr=state->pstart;
   if (state->state == STATE_TEXT)     ptr=state->ptext;
   if (state->state == STATE_ENDTAG)   ptr=state->pend;
   if (state->state == STATE_CDATA)    ptr=state->pcdata;

   /* if we have  len the use it */
   if (len != 0) {
      while (i++<len) {
         *ptr=*str;
	 ptr++; str++;
      }
   }
   /* else do until we reach a zero in the string */
   else {
      while (*str != '\0') {
         *ptr=*str;
	 ptr++; str++;
      }
   }

   /* zero terminate the string */
   *ptr='\0';

   /* update the string pinters */
   if (state->state == STATE_STARTTAG) state->pstart=ptr;
   if (state->state == STATE_TEXT)     state->ptext=ptr;
   if (state->state == STATE_ENDTAG)   state->pend=ptr;
   if (state->state == STATE_CDATA)    state->pcdata=ptr;
}

/* if string is only whitespace, then return nothing*/
inline char *blankIfOnlyWhitespace(char *str) {
   int isWhiteSpace = 1;
   char *ch;
   ch=str;
   
   while (*ch != 0) {
      if (*ch != '\t' && *ch != '\n' && *ch != ' ') { 
	      isWhiteSpace = 0;
	      break;
      }
      ch++;
   }

   if (isWhiteSpace) {
      str[0]=0;
   }
   return str;
}

/* reset pointers */
inline void forgetNode(AppParseState *state) {
   *state->startTag = 0;
   *state->text     = 0;
   *state->endTag   = 0;
   *state->cdata    = 0;
   *state->buffer   = 0;
   state->pstart = state->startTag;
   state->ptext  = state->text;
   state->pend   = state->endTag;
   state->pcdata = state->cdata;
}

/* add a node to the tree */
inline void addNode(AppParseState *state) 
{
  static GtkWidget *subTree;
  char *szBuf;
  GList *list;
  char *szTmp;
  GtkWidget *treeItem = NULL;

  if (state->startTag[0] != 0)
    {
      /* add start tag */
      szBuf = state->buffer;
      strcpy(szBuf, "  ");
      strcat(szBuf, state->startTag);
      szTmp = blankIfOnlyWhitespace(state->text);

      if (state->endTag[0] != 0) 
	{
	  /* we have both start and end tags, so add it all */
	  if (szTmp[0] != 0)
	    {
	      strcat(szBuf, szTmp);
	      strcat(szBuf,state->endTag);
	    }
	  else /* empty tag, <tag></tag> become <tag /> */
	    {
	      szBuf[strlen(szBuf)-1] = '\0';
	      strcat(szBuf, " />");
	    }

	  treeItem = gtk_tree_item_new_with_label(szBuf);
	  gtk_tree_append(GTK_TREE(state->tree), treeItem);
	  gtk_widget_show(treeItem);
	} 
      else
	{
	  /* we have a start tag, and perhaps some text */
	  subTree = gtk_tree_new();
	  treeItem = gtk_tree_item_new_with_label(szBuf);
	  gtk_tree_append(GTK_TREE(state->tree), treeItem);
	  gtk_tree_item_set_subtree (GTK_TREE_ITEM(treeItem), subTree);
	  gtk_widget_show(treeItem);

	  state->tree = subTree;

	  /* add text */
	  if (szTmp[0] != 0)
	    {
	      szBuf = state->buffer;
	      strcpy(szBuf, "  ");
	      strcat(szBuf, szTmp);
	      treeItem = gtk_tree_item_new_with_label(szBuf);
	      gtk_tree_append(GTK_TREE(state->tree), treeItem);
	      gtk_widget_show(treeItem);
	    }
	}
    }
  else 
    {
      if (state->endTag[0] != 0) 
	{
	  /* add cdata */
	  if (state->cdata[0] != 0)
	    {
	      treeItem = gtk_tree_item_new_with_label(state->cdata);
	      list = gtk_container_children(GTK_CONTAINER(treeItem));
	      gtk_misc_set_padding(GTK_MISC(list->data), 12, 0);
	      gtk_tree_append(GTK_TREE(state->tree), treeItem);
	      gtk_widget_show(treeItem);

	      /* treeItem of parent */
	      treeItem = GTK_WIDGET(GTK_TREE(state->tree)->tree_owner);
	      gtk_signal_connect(GTK_OBJECT(treeItem),
				 "collapse",
				 GTK_SIGNAL_FUNC(tree_comment_cdata_collapse),
				 state->tree);
	      gtk_signal_connect(GTK_OBJECT(treeItem),
				 "expand",
				 GTK_SIGNAL_FUNC(tree_comment_cdata_expand),
				 state->tree);
	    }

	  /* add text */
	  szTmp = blankIfOnlyWhitespace(state->text);
	  if (szTmp[0] != 0)
	    {
	      szBuf = state->buffer;
	      strcpy(szBuf, "  ");
	      strcat(szBuf, szTmp);
	      treeItem = gtk_tree_item_new_with_label(szBuf);
	      gtk_tree_append(GTK_TREE(state->tree), treeItem);
	      gtk_widget_show(treeItem);
	    }
	      
	  /* add end node. */
	  treeItem = gtk_tree_item_new_with_label(state->endTag);

	  gtk_tree_append(GTK_TREE(state->tree), treeItem);
	  gtk_widget_show(treeItem);
	  state->tree = state->tree->parent;
	}
    }

  /* once its added, then lets reset everything */
  forgetNode(state);
}

/* sets the parser state */
inline void setState(AppParseState *state, int stateValue) {
   state->state = stateValue;
}

/* allocate the element buffers */
inline void allocateBuffer(AppParseState *state, int len) {
   state->startTag = (gchar *)g_malloc(len * sizeof(gchar));
   state->text = (gchar *)g_malloc(len * sizeof(gchar));
   state->endTag = (gchar *)g_malloc(len * sizeof(gchar));
   state->cdata = (gchar *)g_malloc(len * sizeof(gchar));
   state->buffer = (gchar *)g_malloc(len * 3 * sizeof(gchar));
}

/* SAX handlers */
void handleStartDocument(AppParseState *state) {
   state->state=STATE_UNKNOWN;
   state->startTag = NULL;
   state->text = NULL;
   state->endTag = NULL;
   state->cdata = NULL;
   allocateBuffer(state, MAX_BUFFER_SIZE);
   forgetNode(state);
}

void handleEndDocument(AppParseState *state) {
   g_free(state->startTag);
   g_free(state->text);
   g_free(state->endTag);
   g_free(state->cdata);
   g_free(state->buffer);
}

void handleStartElement(AppParseState *state, char *name, char **attr) {
   setState(state, STATE_STARTTAG);
   addNode(state);

   append(state, "<", 0); append(state, name, 0);
   while (attr != NULL && *attr != NULL) {

     append(state, " ", 0); append(state, *attr,0); append(state, "=", 0);
     attr++;
     append(state, "\"", 0); append(state, *attr, 0); append(state, "\"", 0);
     attr++;
   };
   append(state,">",0);
}

void handleEndElement(AppParseState *state, char *name) {
   setState(state, STATE_ENDTAG);
   append(state, "</", 0); append(state, name, 0); append(state, ">", 0);
   addNode(state);
}

void handleCharacters(AppParseState *state, char *data, int len) {
   setState(state, STATE_TEXT);
   append(state, data, len);
}

void handleCdataBlock(AppParseState *state, char *data, int len)
{
  addNode(state);

  setState(state, STATE_STARTTAG);

  append(state, "<![CDATA[   ]]>", 0);
  addNode(state);

  setState(state, STATE_CDATA);
  append(state, data, len);

  setState(state, STATE_ENDTAG);
  append(state, "]]>", 0);
  addNode(state);
}

void handleComment (AppParseState *state, char *data)
{
  addNode(state);

  setState(state, STATE_STARTTAG);
  append(state, "<!--", 0);

  if (strstr(data, "\n"))
    {
      append(state, "   -->", 0);
      addNode(state);
      setState(state, STATE_CDATA);
    }
  else
    setState(state, STATE_TEXT);

  append(state, data, 0);

  setState(state, STATE_ENDTAG);
  append(state, "-->", 0);
  addNode(state);
}

static void processDTD(AppParseState *state, char *name, char *publicId, char *systemId) {
	char *buf = state->buffer;
	GtkWidget *treeItem;
	*buf = 0;
	strcat(buf, "  <!DOCTYPE ");
	strcat(buf, name);
	if (publicId != NULL) {
		strcat(buf, " PUBLIC \"");
		strcat(buf, publicId);
		strcat(buf, "\"");
	}
	if (systemId != NULL) {
		strcat(buf, " SYSTEM \"");
		strcat(buf, systemId);
		strcat(buf, "\"");
	}
	strcat(buf, ">");
         treeItem = gtk_tree_item_new_with_label(buf);
         gtk_tree_append(GTK_TREE(state->tree), treeItem);
         gtk_widget_show(treeItem);	
}



/* show the parsed xml file in a tree */
int show_xmlfile(const char *filename, GtkWidget *tree) {
   xmlParserCtxtPtr ctxt;
   AppParseState    state;
   const char *fileName = filename;
   int errNo = 0;

   /* Allocate a string buffer for some messages */
   char *strBuf   = (char *)g_malloc(MAX_STRING_BUFFER_SIZE);
   if (strBuf == NULL) {
     g_error("Out of memory!");
	   gtk_exit(99);
   }

   /* Set the default tree state: No Lines */
   gtk_tree_set_view_mode (GTK_TREE (tree), GTK_TREE_VIEW_ITEM);
   gtk_tree_set_view_lines (GTK_TREE (tree), FALSE);

   /* set the tree in the parser state */
   state.tree = tree;
   ctxt = xmlCreateFileParserCtxt(fileName);
   if (!ctxt) {
     g_snprintf(strBuf, MAX_STRING_BUFFER_SIZE, "Unable to parse xml file: %s", fileName);
      errNo = 1;
   }
   if (errNo == 0) {
      ctxt->sax = &appSAXParser;
      ctxt->userData = &state;
      ctxt->validate = 1;
      xmlParseDocument(ctxt);
      if (!ctxt->wellFormed) {     
	g_snprintf(strBuf, MAX_STRING_BUFFER_SIZE,"Xml file: %s, is not well formed.", fileName);
         errNo = 2;
      }
      ctxt->sax = NULL;
      xmlFreeParserCtxt(ctxt);
   }

   /* if we have errors, the lets show them */
   if (errNo != 0) {
         GtkWidget *treeItem;
         treeItem = gtk_tree_item_new_with_label((strBuf != NULL) ? strBuf : "No Message");
         gtk_tree_append(GTK_TREE(tree), treeItem);
         gtk_widget_show(treeItem);
   }

   /* free the string buffer */
   if (strBuf != NULL) g_free(strBuf);
   return errNo;
}

void tree_comment_cdata_collapse (GtkTreeItem *treeItem, gpointer user_data)
{
  GList *list;
  char *end, *start, *new;
  GtkTree *tree;

  g_return_if_fail(user_data != NULL);
  g_return_if_fail(GTK_IS_TREE(user_data));
  tree = GTK_TREE(user_data);
  
  /* All treeItems */
  list = tree->children;
  /* Last teeItem (endTag) */
  list = g_list_last(list);
  g_return_if_fail(GTK_IS_TREE_ITEM(list->data));
  /* Tag name */
  list = gtk_container_children(GTK_CONTAINER(list->data));
  gtk_label_get(GTK_LABEL(list->data), &end);


  /* treeItem tag name */
  list = gtk_container_children(GTK_CONTAINER(treeItem));
  g_return_if_fail(GTK_IS_LABEL(list->data));
  gtk_label_get(GTK_LABEL(list->data), &start);

  /* Concatenates start and end tag */
  new = g_strconcat(start,end, NULL);

  gtk_label_set_text(GTK_LABEL(list->data), new);

  g_free(new);
}

void tree_comment_cdata_expand (GtkTreeItem *treeItem, gpointer user_data)
{
  GList *list;
  char *end, *start, *new;
  GtkTree *tree;

  g_return_if_fail(user_data != NULL);
  g_return_if_fail(GTK_IS_TREE(user_data));
  tree = GTK_TREE(user_data);
  
  /* All treeItems */
  list = tree->children;
  /* Last teeItem (endTag) */
  list = g_list_last(list);
  g_return_if_fail(GTK_IS_TREE_ITEM(list->data));
  /* Tag name */
  list = gtk_container_children(GTK_CONTAINER(list->data));
  gtk_label_get(GTK_LABEL(list->data), &end);

  /* treeItem tag name */
  list = gtk_container_children(GTK_CONTAINER(treeItem));
  g_return_if_fail(GTK_IS_LABEL(list->data));
  gtk_label_get(GTK_LABEL(list->data), &start);

  /* Suppress end tag in start tag */
  new = g_strdup(start);
  start = strstr(new, end);
  if (start) start[0] = '\0';

  gtk_label_set_text(GTK_LABEL(list->data), new);

  g_free(new);
}
